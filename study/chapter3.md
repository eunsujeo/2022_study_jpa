#영속성 관리
JPA가 제공하는 기능
1. 엔티티(객체)와 테이블을 매핑하는 설계 부분
2. 매핑한 엔티티를 실제 사용하는 부분 - 영속성 컨텍스트

## 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리 : 설정 정보를 읽어서 JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스 커넥션 풀을 생성한다. 그러므로 생성하는 비용이 아주 크다.
그러므로 애플리케이션 전체에 서 딱 한번만 생성하고 공유해서 사용해야 한다.
 

- 엔티티 매니저 : JPA의 기능 대부분은 이 엔티티 매니저가 제공한다. 대표적으로 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회할 수 있다.
참고로 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안 된다.

## 영속성 컨텍스트란?
- "엔티티를 영구 저장하는 환경"이라는 뜻
- 눈에 보이지 않는 논리적인 개념
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근하고 관리할 수 있다.

## 엔티티의 생명주기
- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

> 비영속과 준영속 차이?
> 
> 영속상태가 되려면 식별자가 반드시 존재해야 합니다. 그래서 영속 상태가 되었다가 다시 준영속 상태가 되면 식별자가 항상 존재하게 됩니다.
> 사실 실무에서는 이렇게 영속상태가 되었다가 바로 준영속 상태가 되는 일은 드뭅니다.
> 대신에 엔티티를 조회했는데, 트랜잭션이 끝나버리고 영속성 컨택스트도 사라지면 그때 조회한 엔티티가 준영속 상태가 됩니다. 이런 경우는 사실 실무에서 많이 발생합니다.

[비영속 준영속 차이(김영한님 답변)](https://www.inflearn.com/questions/45195)

## 영속성 컨텍스트의 특징
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### 1차 캐시
- 영속성 컨테스트 내부에 있는 캐시
- 영속 상태의 엔티티는 모두 이곳에 저장된다.
> 1차캐시 성능상 이득?
>
> 1차 캐시가 큰 도움은 되지 않는다. entityManager는 데이터베이스 트랜잭션 단위로 만들고 트랜잭션이 끝나면 종료시킨다.
> 고객 요청이 들어와서 비지니스가 끝나게 되면 영속성 컨텍스트를 지운다.(1차 캐시도 날라가게 된다)
> 짧은 찰나의 순간에서만 이득이 있기 때문에 여러 명의 고객이 사용하는 캐시가 아니다.
> 애플리케이션 전체에서 공유하는 캐시는 2차캐시를 사용한다.
> 1차 캐시는 하나의 트랜잭션 안에서만 공유되기 때문에 큰 성능이득은 없다.

### 동일성 보장
- 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공.
> REPEATABLE READ
> 1) Default LEVEL이다.
> 2) SELECT시 현재 시점의 스냅샷을 만들고 스냅샷을 조회한다.
> 3) 동일 트랜잭션 내에서 일관성을 보장한다.
> 4) record lock과 gap lock이 발생한다.
> 5) CREATE SELECT, INSERT SELECT시 lock이 발생한다.

### 트랜잭션을 지원하는 쓰기 지연
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모았다가 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다.
> hibernate의 batch_size 속성의 값을 10으로 주면 최대 10건씩 모아서 SQL 배치를 실행한다.
> ```xml
> <property name="hibernate.jdbc.batch_size" value="10"/>
> ```

### 변경 감지(Dirty Checking)
- JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다. 그리고 flush 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
- 변경 감지는 영속성 컨테스트가 관리하는 영속 상태의 엔티티에만 적용된다.
- JPA의 기본전략은 엔티티의 모든 필드를 업데이트한다.

### 지연 로딩(Lazy Loading)
연관 관계 매핑되어 있는 엔티티 조회 시 프록시를 반환함으로써 쿼리를 진짜 필요할 때 날리는 기능.

## 플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(동기화)한다.(등록, 수정, 삭제쿼리).
> 데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다. 트랜잭션 커밋 직전에만 변경 내용을 데이터베이스에 보내 동기화하면 된다.

### 영속성 컨텍스트를 플러시하는 방법
- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

### 플러시 모드 옵션
- FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값), 쿼리에 영향을 받은 엔티티의 캐시가 있을 때만 플러시한다
> JPA 표준 스펙은 AUTO를 사용하면 모든 변경사항을 flush 하도록 명시되어 있는데, 하이버네이트 구현체는 최적화를 한다.
> 요건 참고 JPA is more strict, and the AUTO flush mode must trigger a flush before any query. More the section 3.10.8 of the Java Persistence API specification says that the AUTO flush mode should ensure that all pending changes are visible by any executing query.
- FlushModeType.COMMIT : 커밋할 때만 플러시

## 준영속 
- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함

### 준영속 만드는 방법
1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환한다
2. em.clear() : 영속성 컨테스트를 완전히 초기화한다.
3. em.close() : 영속성 컨텍스트를 종료한다.

### 준영속 상태의 특징
- 거의 비영속에 가깝다
- 식별자 값을 가지고 있다
- 지연 로딩을 할 수 없다

### 병합 : merge()
- 준영속 상태의 엔티티를 받아서 그 정보로 새로운 영속 상태의 엔티티를 반환한다.